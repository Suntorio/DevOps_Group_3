---
- name: Configure Nginx Web Server with FANCY on Ubuntu 24.04
  hosts: all  # Replace with your server's hostname or IP address
  become: true
  become_method: sudo
  become_user: root
  
  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Install Nginx, OpenSSL, UnZip, Certbot
      apt:
        name: [nginx, openssl, unzip, certbot, python3-certbot-nginx]
        state: present
    
    - name: Download AWS CLI v2 installer
      get_url:
        url: https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip
        dest: /tmp/awscliv2.zip
        mode: '0644'

    - name: Unzip AWS CLI installer
      unarchive:
        src: /tmp/awscliv2.zip
        dest: /tmp
        remote_src: yes
        creates: /tmp/aws/install

    - name: Install AWS CLI v2
      command: /tmp/aws/install
      args:
        creates: /usr/local/bin/aws
    
    # - name: Remove default NGINX site
    #   file:
    #     path: /var/www/html
    #     state: absent

    # - name: Deploy Hugo site
    #   copy:
    #     src: ../../../../hugo/public/
    #     dest: /var/www/html
    #     owner: www-data
    #     group: www-data
    #     mode: "0755"

    - name: Start Nginx
      service:
        name: nginx
        state: started
        enabled: yes

  handlers:
    - name: Reload NGINX
      service:
        name: nginx
        state: reloaded

#Dynamic A-Record Updater on AWS Route 53
- name: Update Route 53 A-record with EC2 public IP
  hosts: all
  gather_facts: false

  vars:
    hosted_zone_id: "Z05114633R8I6QJ512GC"  # Replace with your Hosted Zone ID
    record_name: "alex-tech.us."            # Replace with your domain
    ttl: 300

  tasks:
  # Amazon recently made IMDSv2 the default for all new EC2 instances and Amazon Linux 2023
    - name: Get IMDSv2 Token
      uri:
        url: http://169.254.169.254/latest/api/token
        method: PUT
        headers:
          X-aws-ec2-metadata-token-ttl-seconds: "21600"
        return_content: true  # <--- CRITICAL FIX: Captures the token string
      register: token_response

    - name: Get EC2 public IP using token
      uri:
        url: http://169.254.169.254/latest/meta-data/public-ipv4
        method: GET
        headers:
          # Use the token we just captured, and trim whitespace just in case
          X-aws-ec2-metadata-token: "{{ token_response.content | trim }}"
        return_content: true  # <--- Capture the IP address in the response
      register: public_ip

    - name: Print Public IP (Debug)
      debug:
        msg: "The Public IP is: {{ public_ip.content }}"

    - name: Create change-batch.json with real values
      copy:
        dest: /tmp/change-batch.json
        content: |
          {
            "Comment": "Update A-record with EC2 public IP",
            "Changes": [{
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "{{ record_name }}",
                "Type": "A",
                "TTL": {{ ttl }},
                "ResourceRecords": [{
                  "Value": "{{ public_ip.content }}"
                }]
              }
            }]
          }

    - name: Run AWS CLI to update Route 53 A-record
      command: >
        aws route53 change-resource-record-sets
        --hosted-zone-id {{ hosted_zone_id }}
        --change-batch file:///tmp/change-batch.json

    - name: Show output of CLI command
      debug:
        var: command_result
      when: command_result is defined

# This YAML code assumes you are using Ubuntu/Debian and that your Route 53 DNS is already pointing to this server's IP.
- name: Setup SSL with Certbot
  hosts: all
  become: true
  become_method: sudo
  become_user: root
  
  vars:
    domain_name: "alex-tech.us"
    email_address: "aleks23.la.usa@gmail.com"

  tasks:
    - name: Create directory alex-tech.us
      file:
        path: "/var/www/{{ domain_name }}"
        state: directory
        owner: www-data
        group: www-data
        mode: '0755'

    - name: Copy default Nginx page to the new domain folder
      copy:
        src: /var/www/html/index.nginx-debian.html
        dest: "/var/www/{{ domain_name }}/index.html"
        remote_src: yes  # <--- Essential: tells Ansible the file is already on the server
        owner: www-data
        group: www-data
        mode: '0644'

    # 3. Create a basic NGINX config so Certbot can find the domain
    # This replaces the 'default' file with one containing your server_name
    - name: Create basic NGINX config for domain
      copy:
        dest: "/etc/nginx/sites-available/{{ domain_name }}"
        content: |
          server {
              listen 80;
              server_name {{ domain_name }};
              root /var/www/{{ domain_name }};
              index index.html;
          }
      notify: Reload NGINX

    # 4. Enable the new config
    - name: Enable site configuration
      file:
        src: "/etc/nginx/sites-available/{{ domain_name }}"
        dest: "/etc/nginx/sites-enabled/{{ domain_name }}"
        state: link

    # 5. Remove the default NGINX site to avoid conflicts
    - name: Remove default NGINX config
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: Reload NGINX

    # 6. Flush handlers to ensure NGINX is running with the new server_name
    - meta: flush_handlers

    # 7. Run Certbot to get the SSL certificate
    # --non-interactive: Don't wait for user input
    # --redirect: Automatically update NGINX to force HTTPS
    - name: Run Certbot NGINX plugin
      command: >
        certbot --nginx
        --non-interactive
        --agree-tos
        --email {{ email_address }}
        -d {{ domain_name }}
        --redirect
      args:
        creates: "/etc/letsencrypt/live/{{ domain_name }}/fullchain.pem"

  handlers:
  - name: Reload NGINX
    service:
      name: nginx
      state: reloaded